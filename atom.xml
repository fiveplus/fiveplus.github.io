<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fiveplus Blog</title>
  
  <subtitle>Bonjour le monde</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.ifiveplus.com/"/>
  <updated>2023-11-30T09:09:02.919Z</updated>
  <id>https://blog.ifiveplus.com/</id>
  
  <author>
    <name>Fiveplus</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vscode突然没法调试python2.7</title>
    <link href="https://blog.ifiveplus.com/Vscode%E7%AA%81%E7%84%B6%E6%B2%A1%E6%B3%95%E8%B0%83%E8%AF%95python2.7.html"/>
    <id>https://blog.ifiveplus.com/Vscode突然没法调试python2.7.html</id>
    <published>2023-11-30T09:03:43.000Z</published>
    <updated>2023-11-30T09:09:02.919Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Vscode突然没办法调试<code>python2.7</code>, 且报错<code>...........import _thread as thread; verify_shadowed.check(thread, [&#39;start_new_thread&#39;, &#39;start_new&#39;, &#39;allocate_lock&#39;]) ImportError: No module named _thread</code>, 下面是解决方案</p></blockquote><h2 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h2><p>Vscode最新版本的<code>Python</code>扩展插件只支持python&gt;3.7的版本。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>将Vscode扩展插件<code>Python</code>回滚到2022年以前的版本即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Vscode突然没办法调试&lt;code&gt;python2.7&lt;/code&gt;, 且报错&lt;code&gt;...........import _thread as thread; verify_shadowed.check(thread, [&amp;#39;start
      
    
    </summary>
    
      <category term="Others" scheme="https://blog.ifiveplus.com/categories/Others/"/>
    
    
      <category term="Vscode" scheme="https://blog.ifiveplus.com/tags/Vscode/"/>
    
  </entry>
  
  <entry>
    <title>macOS下AppStore无法登陆的处理方案</title>
    <link href="https://blog.ifiveplus.com/macOS%E4%B8%8BAppStore%E6%97%A0%E6%B3%95%E7%99%BB%E9%99%86%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88.html"/>
    <id>https://blog.ifiveplus.com/macOS下AppStore无法登陆的处理方案.html</id>
    <published>2023-11-23T09:52:00.000Z</published>
    <updated>2023-11-23T09:55:53.822Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在<code>macOS</code>, <code>iPadOS</code>, <code>iOS</code>系统下有时会出现<code>AppStore</code>无法访问的问题，这里说一下如何解决。</p></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>将DNS修改为<code>4.4.2.2</code>后尝试登陆/下载安装</li><li>成功后将DNS改回自动获取即可</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在&lt;code&gt;macOS&lt;/code&gt;, &lt;code&gt;iPadOS&lt;/code&gt;, &lt;code&gt;iOS&lt;/code&gt;系统下有时会出现&lt;code&gt;AppStore&lt;/code&gt;无法访问的问题，这里说一下如何解决。&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
      <category term="MacOS" scheme="https://blog.ifiveplus.com/categories/MacOS/"/>
    
    
      <category term="AppStore" scheme="https://blog.ifiveplus.com/tags/AppStore/"/>
    
  </entry>
  
  <entry>
    <title>macOS下PD19虚拟机安装</title>
    <link href="https://blog.ifiveplus.com/macOS%E4%B8%8BPD19%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85.html"/>
    <id>https://blog.ifiveplus.com/macOS下PD19虚拟机安装.html</id>
    <published>2023-11-10T01:05:00.000Z</published>
    <updated>2023-11-10T01:17:39.236Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>分享一下macOS下虚拟机<code>Parallels Desktop 19</code>破解方案，以及弹出更新如何关闭的方案</p></blockquote><h2 id="安装包下载链接"><a href="#安装包下载链接" class="headerlink" title="安装包下载链接"></a>安装包下载链接</h2><p>下载链接：<a href="https://pan.baidu.com/s/1YI2RbFQaqf4Kb5ctI5zz-w?pwd=5bp6" target="_blank" rel="noopener">https://pan.baidu.com/s/1YI2RbFQaqf4Kb5ctI5zz-w?pwd=5bp6</a></p><h2 id="破解步骤"><a href="#破解步骤" class="headerlink" title="破解步骤"></a>破解步骤</h2><ol><li>下载<code>dmg安装包</code>后，并安装完成<code>Parallels Desktop 19</code></li><li>将<code>Crack_Parallels</code>文件夹从安装包中复制出来</li><li>执行shell脚本<code>Install_Patch.command</code>，会提示要求输入你的本机密码</li><li>第一步输入<code>y</code>，后面默认选择即可</li><li>以后每次启动使用<code>Launch_Parallels.command</code>即可</li></ol><blockquote><p>如果觉得使用脚本启动<code>Parallels Desktop 19</code>比较麻烦的话，可以自行将脚本内容通过<code>自动操作</code>做成app的形式</p></blockquote><h2 id="关于自动更新"><a href="#关于自动更新" class="headerlink" title="关于自动更新"></a>关于自动更新</h2><blockquote><p>建议关闭自动更新，因为更新后该破解方案会失效</p></blockquote><blockquote><p>如果关闭自动更新后，还是弹出升级窗口，请不要点击<code>以后升级</code>，直接点击右上角<code>x</code>关闭窗口即可，否则每次启动都会弹出该升级窗口，且破解会失效</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;分享一下macOS下虚拟机&lt;code&gt;Parallels Desktop 19&lt;/code&gt;破解方案，以及弹出更新如何关闭的方案&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;安装包下载链接&quot;&gt;&lt;a href=&quot;#安装包下载链接&quot; class
      
    
    </summary>
    
      <category term="MacOS" scheme="https://blog.ifiveplus.com/categories/MacOS/"/>
    
    
      <category term="macOS" scheme="https://blog.ifiveplus.com/tags/macOS/"/>
    
      <category term="PD" scheme="https://blog.ifiveplus.com/tags/PD/"/>
    
  </entry>
  
  <entry>
    <title>华为手机adbshell卸载不需要的系统应用</title>
    <link href="https://blog.ifiveplus.com/%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BAadbshell%E5%8D%B8%E8%BD%BD%E4%B8%8D%E9%9C%80%E8%A6%81%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8.html"/>
    <id>https://blog.ifiveplus.com/华为手机adbshell卸载不需要的系统应用.html</id>
    <published>2023-11-07T06:05:32.000Z</published>
    <updated>2023-11-07T06:18:52.946Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>华为手机上有些系统应用广告太多，但是却无法卸载，这里介绍一下如何卸载这些系统应用</p></blockquote><h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><h3 id="adb的下载与环境变量设置"><a href="#adb的下载与环境变量设置" class="headerlink" title="adb的下载与环境变量设置"></a>adb的下载与环境变量设置</h3><p>略</p><h3 id="手机USB调试模式开启"><a href="#手机USB调试模式开启" class="headerlink" title="手机USB调试模式开启"></a>手机USB调试模式开启</h3><p>略</p><h3 id="连接设备"><a href="#连接设备" class="headerlink" title="连接设备"></a>连接设备</h3><p>略</p><h3 id="adb会用到的命令"><a href="#adb会用到的命令" class="headerlink" title="adb会用到的命令"></a>adb会用到的命令</h3><p><code>adb version</code>: 安装完成查看版本号</p><p><code>adb devices</code>: 连接设备</p><p><code>adb shell am monitor</code>: 执行后运行需要卸载的应用，即可看到该应用的包名</p><p><code>adb shell pm list packages</code>: 查看所有应用包名</p><p><code>adb shell pm uninstall -k --user 0 应用包名</code>: 卸载应用，-k表示保存数据</p><p><code>adb shell pm disable -k --user 0 应用包名</code>: 禁用应用,-k表示保存数据</p><p><code>adb shell pm enable -k --user 0 应用包名</code>: 恢复应用,-k表示保存数据</p><p>我卸载的应用（华为音乐，华为浏览器，华为电影，华为智慧助手）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm uninstall -k --user 0 com.huawei.music    </span><br><span class="line">adb shell pm uninstall -k --user 0 com.huawei.browser</span><br><span class="line">adb shell pm uninstall -k --user 0 com.huawei.himovie</span><br><span class="line">adb shell pm uninstall -k --user 0 com.huawei.vassistant</span><br></pre></td></tr></table></figure><p>建议先从<code>华为应用市场</code>-<code>我的</code>-<code>设置</code>中关闭自动更新后再卸载应用</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>参考链接：<a href="https://www.xjx100.cn/news/405554.html?action=onClick" target="_blank" rel="noopener">https://www.xjx100.cn/news/405554.html?action=onClick</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;华为手机上有些系统应用广告太多，但是却无法卸载，这里介绍一下如何卸载这些系统应用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;解决步骤&quot;&gt;&lt;a href=&quot;#解决步骤&quot; class=&quot;headerlink&quot; title=&quot;解决步骤&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Others" scheme="https://blog.ifiveplus.com/categories/Others/"/>
    
    
      <category term="android" scheme="https://blog.ifiveplus.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://blog.ifiveplus.com/hello-world.html"/>
    <id>https://blog.ifiveplus.com/hello-world.html</id>
    <published>2023-10-30T09:55:54.547Z</published>
    <updated>2023-10-30T09:55:54.547Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="hexo" scheme="https://blog.ifiveplus.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://blog.ifiveplus.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse使用SVN提交发生错误的处理方案</title>
    <link href="https://blog.ifiveplus.com/Eclipse%E4%BD%BF%E7%94%A8SVN%E6%8F%90%E4%BA%A4%E5%8F%91%E7%94%9F%E9%94%99%E8%AF%AF%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88.html"/>
    <id>https://blog.ifiveplus.com/Eclipse使用SVN提交发生错误的处理方案.html</id>
    <published>2023-10-24T09:02:52.000Z</published>
    <updated>2023-10-30T09:55:54.538Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在使用2023年9月的<code>Eclipse</code>的时候，使用<code>Subclipse</code>用于SVN版本管理的过程中，在提交代码的时候出现了错误。</p></blockquote><blockquote><p>这是一个eclipse的BUG，是由于SVN连接接口SVNKit的错误导致，SVNKit官方已经修复了这个BUG，但是Eclipse Marketplace还未关联。因此需要手动更新SVNKit，下面讲一下如何更新SVNKit</p></blockquote><h2 id="更新方法"><a href="#更新方法" class="headerlink" title="更新方法"></a>更新方法</h2><p>进入菜单栏<code>Help</code>-&gt;<code>Install New Software</code>，输入地址<code>https://eclipse.svnkit.com/1.10.x/</code>，等待下载更新完成后，重启<code>Eclipse</code>即可。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>BUG链接：<a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=576745" target="_blank" rel="noopener">https://bugs.eclipse.org/bugs/show_bug.cgi?id=576745</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在使用2023年9月的&lt;code&gt;Eclipse&lt;/code&gt;的时候，使用&lt;code&gt;Subclipse&lt;/code&gt;用于SVN版本管理的过程中，在提交代码的时候出现了错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这是
      
    
    </summary>
    
      <category term="MacOS" scheme="https://blog.ifiveplus.com/categories/MacOS/"/>
    
    
      <category term="Eclipse" scheme="https://blog.ifiveplus.com/tags/Eclipse/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池实现原理及其在美团业务中的实践</title>
    <link href="https://blog.ifiveplus.com/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%9C%A8%E7%BE%8E%E5%9B%A2%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5.html"/>
    <id>https://blog.ifiveplus.com/Java线程池实现原理及其在美团业务中的实践.html</id>
    <published>2023-10-13T06:16:13.000Z</published>
    <updated>2023-10-30T09:55:54.541Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>随着计算机行业的飞速发展，摩尔定律逐渐失效，多核CPU成为主流。使用多线程并行计算逐渐成为开发人员提升服务器性能的基本武器。J.U.C提供的线程池：ThreadPoolExecutor类，帮助开发人员管理线程并方便地执行并行任务。了解并合理使用线程池，是一个开发人员必修的基本功。</p></blockquote><blockquote><p>本文开篇简述线程池概念和用途，接着结合线程池的源码，帮助读者领略线程池的设计思路，最后回归实践，通过案例讲述使用线程池遇到的问题，并给出了一种动态化线程池解决方案。</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><h3 id="线程池是什么"><a href="#线程池是什么" class="headerlink" title="线程池是什么"></a>线程池是什么</h3><p>线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。</p><p>线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p><p>而本文描述线程池是JDK中提供的ThreadPoolExecutor类。</p><p>当然，使用线程池可以带来一系列好处：</p><ul><li><code>降低资源消耗</code>: 通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li><li><code>提高响应速度</code>: 任务到达时，无需等待线程创建即可立即执行。</li><li><code>提高线程的可管理性</code>: 线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li><li><code>提供更多更强大的功能</code>: 线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li></ul><h3 id="线程池解决的问题是什么"><a href="#线程池解决的问题是什么" class="headerlink" title="线程池解决的问题是什么"></a>线程池解决的问题是什么</h3><p>线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：</p><ol><li>频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li><li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li><li>系统无法合理管理内部的资源分布，会降低系统的稳定性。</li></ol><p>为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。</p><p>Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia</p><p>“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。</p><p>在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：</p><ol><li>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。</li><li>连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。</li><li>实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</li></ol><p>在了解完“是什么”和“为什么”之后，下面我们来一起深入一下线程池的内部实现原理。</p><h2 id="线程池核心设计与实现"><a href="#线程池核心设计与实现" class="headerlink" title="线程池核心设计与实现"></a>线程池核心设计与实现</h2><p>在前文中，我们了解到：线程池是一种通过“池化”思想，帮助我们管理线程而获取并发性的工具，在Java中的体现是ThreadPoolExecutor类。那么它的的详细设计与实现是什么样的呢？我们会在本章进行详细介绍。</p><h3 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h3><p>Java中的线程池核心实现类是ThreadPoolExecutor，本章基于JDK 1.8的源码来分析Java线程池的核心设计与实现。我们首先来看一下ThreadPoolExecutor的UML类图，了解下ThreadPoolExecutor的继承关系。</p><p><img src="/images/912883e51327e0c7a9d753d11896326511272.png" alt="Thread-Pool-Executor-UML"></p><p>ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。</p><p>ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p><p>ThreadPoolExecutor是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示：</p><p><img src="/images/77441586f6b312a54264e3fcf5eebe2663494.png" alt="Thread-Pool-Executor-流程"></p><p>线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</p><p>接下来，我们会按照以下三个部分去详细讲解线程池运行机制：</p><ol><li>线程池如何维护自身状态。</li><li>线程池如何管理任务。</li><li>线程池如何管理线程。</li></ol><h3 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h3><p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p><code>ctl</code>这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。</p><p>关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125; <span class="comment">//计算当前运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;  <span class="comment">//计算当前线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;   <span class="comment">//通过状态和线程数生成ctl</span></span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor的运行状态有5种，分别为：</p><table><thead><tr><th>运行状态</th><th>状态描述</th></tr></thead><tbody><tr><td><code>RUNNING</code></td><td>能接受新提交的任务，并且也能处理阻塞队列中的任务</td></tr><tr><td><code>SHUTDOWN</code></td><td>关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。</td></tr><tr><td><code>STOP</code></td><td>不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程</td></tr><tr><td><code>TIDYING</code></td><td>所有的任务都已终止了，workCount(有效线程数)为0。</td></tr><tr><td><code>TERMINATED</code></td><td>在terminated()方法执行完成后进入该状态。</td></tr></tbody></table><p>其生命周期转换如下入所示：</p><p><img src="/images/582d1606d57ff99aa0e5f8fc59c7819329028.png" alt="线程池生命周期"></p><h3 id="任务执行机制"><a href="#任务执行机制" class="headerlink" title="任务执行机制"></a>任务执行机制</h3><h4 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h4><p>任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。</p><p>首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：</p><ol><li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li><li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li><li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li></ol><p>其执行流程如下图所示：</p><p><img src="/images/31bad766983e212431077ca8da92762050214.png" alt="任务调度流程"></p><h4 id="任务缓冲"><a href="#任务缓冲" class="headerlink" title="任务缓冲"></a>任务缓冲</h4><p>任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。</p><p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素：</p><p><img src="/images/f4d89c87acf102b45be8ccf3ed83352a9497.png" alt="阻塞队列"></p><p>使用不同的队列可以实现不一样的任务存取策略。在这里，我们可以再介绍下阻塞队列的成员：</p><p><img src="/images/725a3db5114d95675f2098c12dc331c3316963.png" alt="阻塞队列-2"></p><h4 id="任务申请"><a href="#任务申请" class="headerlink" title="任务申请"></a>任务申请</h4><p>由上文的任务分配部分可知，任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。</p><p>线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现，其执行流程如下图所示：</p><p><img src="/images/49d8041f8480aba5ef59079fcc7143b996706.png" alt="获取任务流程图"></p><p>getTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。</p><h4 id="任务拒绝"><a href="#任务拒绝" class="headerlink" title="任务拒绝"></a>任务拒绝</h4><p>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。</p><p>拒绝策略是一个接口，其设计如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下：</p><p><img src="/images/9ffb64cc4c64c0cb8d38dac01c89c905178456-1.png" alt="拒绝策略"></p><h3 id="Worker线程管理"><a href="#Worker线程管理" class="headerlink" title="Worker线程管理"></a>Worker线程管理</h3><h4 id="Worker线程"><a href="#Worker线程" class="headerlink" title="Worker线程"></a>Worker线程</h4><p>线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。我们来看一下它的部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread;<span class="comment">//Worker持有的线程</span></span><br><span class="line">    Runnable firstTask;<span class="comment">//初始化的任务，可以为null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Worker这个工作线程，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。</p><p>Worker执行任务的模型如下图所示：</p><p><img src="/images/03268b9dc49bd30bb63064421bb036bf90315.png" alt="Worker执行任务"></p><p>线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。</p><p>​Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。</p><p>lock方法一旦获取了独占锁，表示当前线程正在执行任务中。 2.如果正在执行任务，则不应该中断线程。 3.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 4.线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</p><p>在线程回收过程中就使用到了这种特性，回收过程如下图所示：</p><p><img src="/images/9d8dc9cebe59122127460f81a98894bb34085-2.png" alt="线程池回收过程"></p><h4 id="Worker线程增加"><a href="#Worker线程增加" class="headerlink" title="Worker线程增加"></a>Worker线程增加</h4><p>增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。addWorker方法有两个参数：firstTask、core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空；core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，其执行流程如下图所示：</p><p><img src="/images/49527b1bb385f0f43529e57b614f59ae145454.png" alt="申请线程执行流程图"></p><h4 id="Worker线程回收"><a href="#Worker线程回收" class="headerlink" title="Worker线程回收"></a>Worker线程回收</h4><p>线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  processWorkerExit(w, completedAbruptly);<span class="comment">//获取不到任务时，主动回收自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程回收的工作是在processWorkerExit方法完成的。</p><p><img src="/images/90ea093549782945f2c968403fdc39d415386.png" alt="线程销毁流程"></p><p>事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。</p><h4 id="Worker线程执行任务"><a href="#Worker线程执行任务" class="headerlink" title="Worker线程执行任务"></a>Worker线程执行任务</h4><p>在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：</p><ol><li>while循环不断地通过getTask()方法获取任务。</li><li>getTask()方法从阻塞队列中取任务。 </li><li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 </li><li>执行任务。 </li><li>如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。</li></ol><p>执行流程如下图所示：</p><p><img src="/images/879edb4f06043d76cea27a3ff358cb1d45243.png" alt="执行任务流程"></p><h2 id="线程池在业务中的实践"><a href="#线程池在业务中的实践" class="headerlink" title="线程池在业务中的实践"></a>线程池在业务中的实践</h2><h3 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h3><p>在当今的互联网业界，为了最大程度利用CPU的多核性能，并行运算的能力是不可或缺的。通过线程池管理线程获取并发性是一个非常基础的操作，让我们来看两个典型的使用线程池获取并发性的场景。</p><p><strong>场景1：快速响应用户请求</strong></p><p><code>描述</code>：用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。</p><p><code>分析</code>：从用户体验角度看，这个结果响应的越快越好，如果一个页面半天都刷不出，用户可能就放弃查看这个商品了。而面向用户的功能聚合通常非常复杂，伴随着调用与调用之间的级联、多级级联等情况，业务开发同学往往会选择使用线程池这种简单的方式，将调用封装成任务并行的执行，缩短总体响应时间。另外，使用线程池也是有考量的，这种场景最重要的就是获取最大的响应速度去满足用户，所以应该不设置队列去缓冲并发任务，调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务。</p><p><img src="/images/e9a363c8577f211577e4962e9110cb0226733.png" alt="并行执行任务提升任务响应速度"></p><p><strong>场景2：快速处理批量任务</strong></p><p><code>描述</code>：离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。</p><p><code>分析</code>：这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。所以应该设置队列去缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数。在这里，设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。</p><p><img src="/images/1a1746f33bfdcb03da074d8539ebb2f367563.png" alt="并行执行任务提升批量任务响应速度"></p><h3 id="实际问题及方案思考"><a href="#实际问题及方案思考" class="headerlink" title="实际问题及方案思考"></a>实际问题及方案思考</h3><p>线程池使用面临的核心的问题在于：<strong>线程池的参数并不好配置</strong>，一方面线程池的运行机制不是很好理解，配置合理需要强依赖开发人员的个人经验和知识；另一方面，线程池执行的情况和任务类型相关性较大，IO密集型和CPU密集型的任务运行起来的情况差异非常大，这导致业界并没有一些成熟的经验策略帮助开发人员参考。</p><p>关于线程池配置不合理引发的故障，公司内部有较多记录，下面举一些例子：</p><p><code>Case1</code>: 2018年XX页面展示接口大量调用降级</p><p><code>事故描述</code>: XX页面展示接口产生大量调用降级，数量级在几十到上百。</p><p><code>事故原因</code>: 该服务展示接口内部逻辑使用线程池做并行计算，由于没有预估好调用的流量，导致最大核心数设置偏小，大量抛出RejectedExecutionException，触发接口降级条件，示意图如下：</p><p><img src="/images/1df932840b31f41931bb69e16be2932844240.png" alt="线程池核心设置过小引发RejectExecutionException"></p><p><code>Case2</code>：2018年XX业务服务不可用S2级故障</p><p><code>事故描述</code>：XX业务提供的服务执行时间过长，作为上游服务整体超时，大量下游服务调用失败。</p><p><code>事故原因</code>：该服务处理请求内部逻辑使用线程池做资源隔离，由于队列设置过长，最大线程数设置失效，导致请求数量增加时，大量任务堆积在队列中，任务执行时间过长，最终导致下游服务的大量调用超时失败。示意图如下：</p><p><img src="/images/668e3c90f4b918bfcead2f4280091e9757284.png" alt="线程池队列长度设置过长，corePoolSize设置过小导致执行速度低"></p><p>业务中要使用线程池，而使用不当又会导致故障，那么我们怎样才能更好地使用线程池呢？针对这个问题，我们下面延展几个方向：</p><ol><li>能否不用线程池?</li></ol><p>回到最初的问题，业务使用线程池是为了获取并发性，对于获取并发性，是否可以有什么其他的方案呢替代？我们尝试进行了一些其他方案的调研：</p><p><img src="/images/56ab763273b2c03b2f1c37db7b150338414771.png" alt="并发框架"></p><p>综合考虑，这些新的方案都能在某种情况下提升并行任务的性能，然而本次重点解决的问题是如何更简易、更安全地获得的并发性。另外，Actor模型的应用实际上甚少，只在Scala中使用广泛，协程框架在Java中维护的也不成熟。这三者现阶段都不是足够的易用，也并不能解决业务上现阶段的问题。</p><ol start="2"><li>追求参数设置合理性？</li></ol><p>有没有一种计算公式，能够让开发同学很简易地计算出某种场景中的线程池应该是什么参数呢？</p><p>带着这样的疑问，我们调研了业界的一些线程池参数配置方案：</p><p><img src="/images/23a44974ff68a08261fb675242b83648181953.png" alt="方案"></p><p>调研了以上业界方案后，我们并没有得出通用的线程池计算方式。并发任务的执行情况和任务类型相关，IO密集型和CPU密集型的任务运行起来的情况差异非常大，但这种占比是较难合理预估的，这导致很难有一个简单有效的通用公式帮我们直接计算出结果。</p><ol start="3"><li>线程池参数动态化？</li></ol><p>尽管经过谨慎的评估，仍然不能够保证一次计算出来合适的参数，那么我们是否可以将修改线程池参数的成本降下来，这样至少可以发生故障的时候可以快速调整从而缩短故障恢复的时间呢？基于这个思考，我们是否可以将线程池的参数从代码中迁移到分布式配置中心上，实现线程池参数可动态配置和即时生效，线程池参数动态化前后的参数修改流程对比如下：</p><p><img src="/images/c6caa5be64f39758ada0593b995d65fd25982.png" alt="动态修改线程池参数新旧流程对比"></p><p>基于以上三个方向对比，我们可以看出参数动态化方向简单有效。</p><h3 id="动态化线程池"><a href="#动态化线程池" class="headerlink" title="动态化线程池"></a>动态化线程池</h3><h4 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h4><p>动态化线程池的核心设计包括以下三个方面：</p><ol><li>简化线程池配置：线程池构造参数有8个，但是最核心的是3个：corePoolSize、maximumPoolSize，workQueue，它们最大程度地决定了线程池的任务分配和线程分配策略。考虑到在实际应用中我们获取并发性的场景主要是两种：（1）并行执行子任务，提高响应速度。这种情况下，应该使用同步队列，没有什么任务应该被缓存下来，而是应该立即执行。（2）并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积。所以线程池只需要提供这三个关键参数的配置，并且提供两种队列的选择，就可以满足绝大多数的业务需求，Less is More。</li><li>参数可动态修改：为了解决参数不好配，修改参数成本高等问题。在Java线程池留有高扩展性的基础上，封装线程池，允许线程池监听同步外部的消息，根据消息进行修改配置。将线程池的配置放置在平台侧，允许开发同学简单的查看、修改线程池配置。</li><li>增加线程池监控：对某事物缺乏状态的观测，就对其改进无从下手。在线程池执行任务的生命周期添加监控能力，帮助开发同学了解线程池状态。</li></ol><p><img src="/images/4d5c410ad23782350cc9f980787151fd54144.png" alt="动态线程池整体设计"></p><h4 id="功能架构"><a href="#功能架构" class="headerlink" title="功能架构"></a>功能架构</h4><p>动态化线程池提供如下功能：</p><p><code>动态调参</code>：支持线程池参数动态调整、界面化操作；包括修改线程池核心大小、最大核心大小、队列长度等；参数修改后及时生效。 </p><p><code>任务监控</code>：支持应用粒度、线程池粒度、任务粒度的Transaction监控；可以看到线程池的任务执行情况、最大任务执行时间、平均任务执行时间、95/99线等。 </p><p><code>负载告警</code>：线程池队列任务积压到一定值的时候会通过大象（美团内部通讯工具）告知应用开发负责人；当线程池负载数达到一定阈值的时候会通过大象告知应用开发负责人。 </p><p><code>操作监控</code>：创建/修改和删除线程池都会通知到应用的开发负责人。 </p><p><code>操作日志</code>：可以查看线程池参数的修改记录，谁在什么时候修改了线程池参数、修改前的参数值是什么。 </p><p><code>权限校验</code>：只有应用开发负责人才能够修改应用的线程池参数。</p><p><img src="/images/6c0091e92e90f50f89fd83f3b9eb5472135718.png" alt="动态化线程池功能架构"></p><p><strong>参数动态化</strong></p><p>JDK原生线程池ThreadPoolExecutor提供了如下几个public的setter方法，如下图所示：</p><p><img src="/images/efd32f1211e9cf0a3ca9d35b0dc5de8588353.png" alt="JDK线程池参数设置接口"></p><p>JDK允许线程池使用方通过ThreadPoolExecutor的实例来动态设置线程池的核心策略，以setCorePoolSize为方法例，在运行期线程池使用方调用此方法设置corePoolSize之后，线程池会直接覆盖原来的corePoolSize值，并且基于当前值和原始值的比较结果采取不同的处理策略。对于当前值小于当前工作线程数的情况，说明有多余的worker线程，此时会向当前idle的worker线程发起中断请求以实现回收，多余的worker在下次idel的时候也会被回收；对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的worker线程来执行队列任务，setCorePoolSize具体流程如下：</p><p><img src="/images/9379fe1666818237f842138812bf63bd85645.png" alt="setCorePoolSize方法执行流程"></p><p>线程池内部会处理好当前状态做到平滑修改，其他几个方法限于篇幅，这里不一一介绍。重点是基于这几个public方法，我们只需要维护ThreadPoolExecutor的实例，并且在需要修改的时候拿到实例修改其参数即可。基于以上的思路，我们实现了线程池参数的动态化、线程池参数在管理平台可配置可修改，其效果图如下图所示：</p><p><img src="/images/414ba7f3abd11e5f805c58635ae10988166121.png" alt="可动态修改线程池参数"></p><p>用户可以在管理平台上通过线程池的名字找到指定的线程池，然后对其参数进行修改，保存后会实时生效。目前支持的动态参数包括核心数、最大值、队列长度等。除此之外，在界面中，我们还能看到用户可以配置是否开启告警、队列等待任务告警阈值、活跃度告警等等。关于监控和告警，我们下面一节会对齐进行介绍。</p><p><strong>线程池监控</strong></p><p>除了参数动态化之外，为了更好地使用线程池，我们需要对线程池的运行状况有感知，比如当前线程池的负载是怎么样的？分配的资源够不够用？任务的执行情况是怎么样的？是长任务还是短任务？基于对这些问题的思考，动态化线程池提供了多个维度的监控和告警能力，包括：线程池活跃度、任务的执行Transaction（频率、耗时）、Reject异常、线程池内部统计信息等等，既能帮助用户从多个维度分析线程池的使用情况，又能在出现问题第一时间通知到用户，从而避免故障或加速故障恢复。</p><ol><li>负载监控和告警</li></ol><p>线程池负载关注的核心问题是：基于当前线程池参数分配的资源够不够。对于这个问题，我们可以从事前和事中两个角度来看。事前，线程池定义了“活跃度”这个概念，来让用户在发生Reject异常之前能够感知线程池负载问题，线程池活跃度计算公式为：线程池活跃度 = activeCount/maximumPoolSize。这个公式代表当活跃线程数趋向于maximumPoolSize的时候，代表线程负载趋高。事中，也可以从两方面来看线程池的过载判定条件，一个是发生了Reject异常，一个是队列中有等待任务（支持定制阈值）。以上两种情况发生了都会触发告警，告警信息会通过大象推送给服务所关联的负责人。</p><p><img src="/images/04e73f7186a91d99181e1b5615ce9e4a318600.png" alt="告警通知"></p><ol start="2"><li>任务级精细化监控</li></ol><p>在传统的线程池应用场景中，线程池中的任务执行情况对于用户来说是透明的。比如在一个具体的业务场景中，业务开发申请了一个线程池同时用于执行两种任务，一个是发消息任务、一个是发短信任务，这两类任务实际执行的频率和时长对于用户来说没有一个直观的感受，很可能这两类任务不适合共享一个线程池，但是由于用户无法感知，因此也无从优化。动态化线程池内部实现了任务级别的埋点，且允许为不同的业务任务指定具有业务含义的名称，线程池内部基于这个名称做Transaction打点，基于这个功能，用户可以看到线程池内部任务级别的执行情况，且区分业务，任务监控示意图如下图所示：</p><p><img src="/images/cd0b9445c3c93a866201b7cfb24d2ce7214776.png" alt="线程池任务执行监控"></p><ol start="3"><li>运行时状态实时查看</li></ol><p>用户基于JDK原生线程池ThreadPoolExecutor提供的几个public的getter方法，可以读取到当前线程池的运行状态以及参数，如下图所示：</p><p><img src="/images/aba8d9c09e6f054c7061ddd720a04a26147951.png" alt="线程池实时运行情况"></p><p>动态化线程池基于这几个接口封装了运行时状态实时查看的功能，用户基于这个功能可以了解线程池的实时状态，比如当前有多少个工作线程，执行了多少个任务，队列中等待的任务数等等。效果如下图所示：</p><p><img src="/images/38d5fbeaebd4998f3a30d44bd20b996f113233-1.png" alt="线程池实时运行情况"></p><h3 id="实践总结"><a href="#实践总结" class="headerlink" title="实践总结"></a>实践总结</h3><p>面对业务中使用线程池遇到的实际问题，我们曾回到支持并发性问题本身来思考有没有取代线程池的方案，也曾尝试着去追求线程池参数设置的合理性，但面对业界方案具体落地的复杂性、可维护性以及真实运行环境的不确定性，我们在前两个方向上可谓“举步维艰”。最终，我们回到线程池参数动态化方向上探索，得出一个且可以解决业务问题的方案，虽然本质上还是没有逃离使用线程池的范畴，但是在成本和收益之间，算是取得了一个很好的平衡。成本在于实现动态化以及监控成本不高，收益在于：在不颠覆原有线程池使用方式的基础之上，从降低线程池参数修改的成本以及多维度监控这两个方面降低了故障发生的概率。希望本文提供的动态化线程池思路能对大家有帮助。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>参考链接：<a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;随着计算机行业的飞速发展，摩尔定律逐渐失效，多核CPU成为主流。使用多线程并行计算逐渐成为开发人员提升服务器性能的基本武器。J.U.C提供的线程池：ThreadPoolExecutor类，帮助开发人员管理线程并方便地执行并行任务。了解并合理使用线程
      
    
    </summary>
    
      <category term="Java" scheme="https://blog.ifiveplus.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.ifiveplus.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>OpenCore升级不受支持的macbook</title>
    <link href="https://blog.ifiveplus.com/OpenCore%E5%8D%87%E7%BA%A7%E4%B8%8D%E5%8F%97%E6%94%AF%E6%8C%81%E7%9A%84macbook.html"/>
    <id>https://blog.ifiveplus.com/OpenCore升级不受支持的macbook.html</id>
    <published>2023-10-10T03:16:00.000Z</published>
    <updated>2023-10-30T09:55:54.543Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>macbook2015pro已经不在macOS Sonoma支持范围内，本文讲解macbook2015pro如何升级到macOS Sonoma</p></blockquote><h2 id="创建安装程序"><a href="#创建安装程序" class="headerlink" title="创建安装程序"></a>创建安装程序</h2><p>借助 OpenCore Legacy Patcher，我们的新 GUI 包含 macOS 安装程序的下载菜单。因此，首先，您需要获取我们的应用程序：<a href="https://github.com/dortania/OpenCore-Legacy-Patcher/releases" target="_blank" rel="noopener">https://github.com/dortania/OpenCore-Legacy-Patcher/releases</a></p><p>在本指南中，我们将使用标准 OpenCore-Patcher (GUI)。</p><p>下载后，打开应用程序，您应该会看到以下菜单：</p><p><img src="/images/OCLP-GUI-Main-Menu.40fc1dad.png" alt="OCLP-GUI-Main-Menu"></p><p>首先，我们要选择“创建 macOS 安装程序”按钮。这将为您提供 2 个选项：</p><p><img src="/images/OCLP-GUI-Create-Installer-Menu.6220ded8.png" alt="OCLP-GUI-Main-Menu"></p><p>对于此示例，我们假设您需要一个安装程序。选择此选项将下载 Apple 的安装程序目录并构建一个列表供您选择：</p><table><thead><tr><th>正在下载</th><th>列出的安装商</th><th>不受支持的安装程序</th></tr></thead><tbody><tr><td><img src="/images/OCLP-GUI-Installer-Download-Catalog.cb53a9a5.png" alt="OCLP-GUI-Installer-Download-Catalog"></td><td><img src="/images/OCLP-GUI-Installer-Download-Listed-Products.e77dd4c3.png" alt="OCLP-GUI-Installer-Download-Listed-Products"></td><td><img src="/images/OCLP-GUI-Installer-Download-Unsupported.c42dd553.png" alt="OCLP-GUI-Installer-Download-Unsupported"></td></tr></tbody></table><p>由于修补程序正式支持 Big Sur 和更新版本的修补程序，因此只会显示那些完整的修补程序。对于我们自己来说，我们将选择 macOS 12，因为这是撰写本文时的最新公开版本。这会将 macOS 安装程序下载并安装到您的应用程序文件夹中。</p><blockquote><p>请注意，macOS Ventura 当前可能不支持某些计算机（即 2012 年及更早版本）。如果您看到此提示，则您需要使用旧版本的 macOS。</p></blockquote><table><thead><tr><th>下载安装程序</th><th>请求安装</th><th>安装完成</th></tr></thead><tbody><tr><td><img src="/images/OCLP-GUI-Installer-Download-Progress.84e96f79.png" alt="OCLP-GUI-Installer-Download-Progress"></td><td><img src="/images/OCLP-GUI-Installer-Needs-Installing.297e4912.png" alt="OCLP-GUI-Installer-Needs-Installing"></td><td><img src="/images/OCLP-GUI-Installer-Download-Finished.ecc832c2.png" alt="OCLP-GUI-Installer-Download-Finished"></td></tr></tbody></table><p>完成后，您可以继续将安装程序写入 USB 驱动器。</p><blockquote><p>注意：整个 USB 驱动器将被格式化</p></blockquote><table><thead><tr><th>选择下载的安装程序</th><th>选择要格式化的磁盘</th></tr></thead><tbody><tr><td><img src="/images/OCLP-GUI-Installer-Select-Local-Installer.88e785bd.png" alt="OCLP-GUI-Installer-Select-Local-Installer"></td><td><img src="/images/OCLP-GUI-Installer-Format-USB.a14e2cea.png" alt="OCLP-GUI-Installer-Format-USB"></td></tr></tbody></table><p>现在修补程序将开始安装程序闪烁！</p><table><thead><tr><th>闪烁</th><th>成功提示</th><th>闪烁完成</th></tr></thead><tbody><tr><td><img src="/images/OCLP-GUI-Installer-Flashing-Process.1d538441.png" alt="OCLP-GUI-Installer-Flashing-Process"></td><td><img src="/images/OCLP-GUI-Installer-Sucess-Prompt.d2daa669.png" alt="OCLP-GUI-Installer-Sucess-Prompt"></td><td><img src="/images/OCLP-GUI-Installer-Finished-Script.554b202c.png" alt="OCLP-GUI-Installer-Finished-Script"></td></tr></tbody></table><p>完成后，前往构建和安装 OpenCore</p><h2 id="构建和安装-OpenCore"><a href="#构建和安装-OpenCore" class="headerlink" title="构建和安装 OpenCore"></a>构建和安装 OpenCore</h2><p>现在我们已经有了 macOS 安装程序，现在让我们构建 OpenCore 配置！</p><p>如果您尚未下载 OpenCore Patcher，请立即下载：<a href="https://github.com/dortania/OpenCore-Legacy-Patcher/releases" target="_blank" rel="noopener">https://github.com/dortania/OpenCore-Legacy-Patcher/releases</a></p><p>接下来，运行<code>OpenCore-Patcher.app</code>:</p><p><img src="/images/OCLP-GUI-Main-Menu.40fc1dad.png" alt="OCLP-GUI-Main-Menu"></p><blockquote><p>OpenCore 配置是特定于硬件的。如果您正在为与当前运行的模型不同的模型构建 OpenCore，则绝对有必要从“设置”中选择正确的模型。</p></blockquote><p>在这里我们将选择 Build and Install OpenCore 并开始构建：</p><table><thead><tr><th>开始建造</th><th>竣工建筑</th></tr></thead><tbody><tr><td><img src="/images/OCLP-GUI-Build-Start.61964260.png" alt="OCLP-GUI-Build-Start"></td><td><img src="/images/OCLP-GUI-Build-Finished.8fc0d8ea.png" alt="OCLP-GUI-Build-Finished"></td></tr></tbody></table><p>构建完成后，您需要选择“安装 OpenCore”按钮：</p><blockquote><p>如果您手动创建了 macOS USB，但没有看到它列出，请确保它的格式为 GUID/GPT，或者具有供 OpenCore 驻留的 FAT32 分区。</p></blockquote><table><thead><tr><th>选择驱动器</th><th>选择分区</th></tr></thead><tbody><tr><td><img src="/images/OCLP-GUI-EFI-Select-Disk.d9a3392f.png" alt="OCLP-GUI-EFI-Select-Disk"></td><td><img src="/images/OCLP-GUI-EFI-Select-Partition.131e5d28.png" alt="OCLP-GUI-EFI-Select-Partition"></td></tr></tbody></table><p>完成后，前往引导 OpenCore 和 macOS</p><h2 id="引导-OpenCore-和-macOS"><a href="#引导-OpenCore-和-macOS" class="headerlink" title="引导 OpenCore 和 macOS"></a>引导 OpenCore 和 macOS</h2><h3 id="启动OpenCore"><a href="#启动OpenCore" class="headerlink" title="启动OpenCore"></a>启动OpenCore</h3><p>现在我们终于可以启动 OpenCore 了！</p><p>重新启动机器，同时按住<code>Option</code>选择带有 OpenCore 图标的 EFI 启动项（按住该<code>Control</code>键将使该启动项成为默认启动项）：</p><blockquote><p>这将是 Mac 启动选择器</p></blockquote><p><img src="/images/efi-boot.8307f610.png" alt="efi-boot"></p><h3 id="对于配备未闪存-GPU-的-Mac-Pro-Xserve-iMac-的注意事项"><a href="#对于配备未闪存-GPU-的-Mac-Pro-Xserve-iMac-的注意事项" class="headerlink" title="对于配备未闪存 GPU 的 Mac Pro/Xserve/iMac 的注意事项"></a>对于配备未闪存 GPU 的 Mac Pro/Xserve/iMac 的注意事项</h3><p>改编自<a href="https://forums.macrumors.com/threads/manually-configured-opencore-on-the-mac-pro.2207814/" target="_blank" rel="noopener">Mac Pro 上的 OpenCore 指南</a></p><p>对于使用非闪存 GPU 的 Mac Pro、Xserve 和 iMac 用户，您仍然可以轻松启动 OpenCore 并查看整个启动过程。</p><p>首先，打开终端并运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nvram "recovery-boot-mode=unused" &amp;&amp; sudo reboot recovery</span><br></pre></td></tr></table></figure><p>这将使您的计算机重新启动进入恢复环境。或者，在计算机启动时按住<code>Command</code>+<code>R</code>也可以让您进入恢复。</p><p>其次，打开恢复环境的终端（菜单栏 &gt; 实用程序 &gt; 终端）。</p><p>现在您需要获取驱动器标识符列表。为此，请运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskutil list</span><br></pre></td></tr></table></figure><p>该命令应生成系统中安装的驱动器列表：</p><p><img src="/images/Unflashed-Boot-1.ba0e58a4.png" alt="Unflashed-Boot-1"></p><p>通过 OCLP 安装跟踪驱动器。稍后您将需要驱动器标识符。</p><p>现在您需要挂载 EFI 分区（安装 OCLP 的位置，但如果您将 OCLP 安装到 FAT-32 卷，情况可能会有所不同）。</p><p>运行以下命令（将 X 替换为驱动器号）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskutil mount diskXs1</span><br></pre></td></tr></table></figure><p><img src="/images/Unflashed-Boot-2.5e873f39.png" alt="Unflashed-Boot-2"></p><p>如果一切正确，则应该安装 EFI 分区。</p><p>现在您需要使用以下<code>bless</code>命令来设置默认启动设备：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bless --mount /Volumes/EFI --setBoot --file /Volumes/EFI/System/Library/CoreServices/boot.efi</span><br></pre></td></tr></table></figure><p>该命令运行后，不应产生任何输出。</p><p><img src="/images/Unflashed-Boot-3.79f71d03.png" alt="Unflashed-Boot-3"></p><p>如果该命令产生输出，请确保您输入的内容正确无误。</p><p>现在您可以重新启动机器。OCLP 现在是默认启动选项！</p><h3 id="安装macOS"><a href="#安装macOS" class="headerlink" title="安装macOS"></a>安装macOS</h3><p>现在您已经加载了 OpenCore，“选择安装 macOS”：</p><blockquote><p>这将是 OpenCore 选择器</p></blockquote><p><img src="/images/oc-boot.3c2bdab5.png" alt="oc-boot"></p><p>您很快就会到达安装程序屏幕！如果您在构建 OCLP 时启用了详细模式，则会在屏幕上显示大量文本。从那里开始，它就像任何普通的 macOS 安装一样。有关启动过程的示例，请观看以下视频：</p><p><a href="https://www.youtube.com/watch?v=AN3zsbQV_n4" target="_blank" rel="noopener">OpenCore 旧版修补程序启动过程</a></p><p>如果您的 Mac 在第一次重新启动后循环回到设置的开头，请将其关闭，再次启动并按住Option。这次，选择带有灰色硬盘图标的选项，它可以显示“macOS Installer”或您在安装程序过程中为磁盘指定的名称。如有必要，每次重新启动后请继续重复此步骤。</p><p><img src="/images/oclp-stuck-firstreboot.12edd7b4.png" alt="oclp-stuck-firstreboot"></p><blockquote><p>MacBookPro11,3 注意：启动 macOS Monterey 时，如果尚未安装加速补丁，则需要启动到安全模式。<a href="https://github.com/dortania/OpenCore-Legacy-Patcher/issues/522" target="_blank" rel="noopener">否则，您将因缺少 NVIDIA 驱动程序而出现黑屏</a>。 <code>Shift</code> + <code>Enter</code>在 OCLP 的启动菜单中选择 macOS Monterey 时按住可进入安全模式。</p></blockquote><p>安装并启动后，前往安装后</p><h2 id="安装后"><a href="#安装后" class="headerlink" title="安装后"></a>安装后</h2><h3 id="无需USB驱动器启动"><a href="#无需USB驱动器启动" class="headerlink" title="无需USB驱动器启动"></a>无需USB驱动器启动</h3><p>通过 OpenCore 安装 macOS 后，您可以启动并完成常规安装过程。在不插入 USB 驱动器的情况下启动非常简单：</p><ol><li>下载 OpenCore 旧版补丁程序</li><li>根据需要更改修补程序设置</li><li>再次构建 OpenCore</li><li>将 OpenCore 安装到内部驱动器</li><li>重启按住Option，选择内部EFI</li></ol><p>瞧！不再需要 USB 驱动器。</p><h3 id="无需启动选择器即可无缝启动"><a href="#无需启动选择器即可无缝启动" class="headerlink" title="无需启动选择器即可无缝启动"></a>无需启动选择器即可无缝启动</h3><p>为此，请运行 OpenCore Patcher 并前往 Patcher Settings，然后取消选中 Build 选项卡上的“Show OpenCore Bootpicker”：</p><p><img src="/images/OCLP-GUI-Settings-ShowPicker.5831a6a8.png" alt="OCLP-GUI-Settings-ShowPicker"></p><p>将其关闭后，再次构建 OpenCore EFI 并安装到所需的驱动器。现在要显示 OpenCore 选择器，您只需在单击 EFI 启动时按住“ESC”键，然后当您看到左上角的光标箭头时即可释放“ESC”键。</p><h3 id="启用SIP"><a href="#启用SIP" class="headerlink" title="启用SIP"></a>启用SIP</h3><p>对于许多用户来说，SIP 将在构建时默认降低。对于 Intel HD 4000 用户，您可能已经注意到 SIP 被部分禁用。这是为了确保与 macOS Monterey 完全兼容，并允许它与旧操作系统之间无缝启动。但是，对于不打算启动 Monterey 的用户，您可以在“修补程序设置”下重新启用。</p><blockquote><p>注意：运行 macOS Ventura 的计算机或具有非 Metal GPU 的系统无法完全启用 SIP，因为根卷已打补丁。启用它会使安装变砖。</p></blockquote><p>从 0.6.6 开始，可以从图像中显示的“安全”选项卡访问 SIP 设置。</p><table><thead><tr><th>启用 SIP</th><th>SIP 降低（根修补）</th><th>SIP 已禁用</th></tr></thead><tbody><tr><td><img src="/images/OCLP-GUI-Settings-SIP-Enabled.f95aadf0.png" alt="OCLP-GUI-Settings-SIP-Enabled"></td><td><img src="/images/OCLP-GUI-Settings-SIP-Root-Patch.b983af09.png" alt="OCLP-GUI-Settings-SIP-Root-Patch"></td><td><img src="/images/OCLP-GUI-Settings-SIP-Disabled.960a27d1.png" alt="OCLP-GUI-Settings-SIP-Disabled"></td></tr></tbody></table><blockquote><p>如果您不确定是否应该启用 SIP，请保持原样。已运行安装后根修补的系统无法在不破坏当前安装的情况下启用 SIP。</p></blockquote><h3 id="应用安装后卷补丁"><a href="#应用安装后卷补丁" class="headerlink" title="应用安装后卷补丁"></a>应用安装后卷补丁</h3><p>安装后卷补丁（有时也称为根补丁）是一些旧 Mac 必须安装到磁盘才能恢复功能的补丁。</p><p>如果 USB 安装介质是在 OCLP 中创建的，则OCLP 将在首次安装期间自动对系统进行根修补。macOS 更新后或系统上未检测到补丁时，系统还会提示用户安装这些补丁。我们建议使用最新版本的 OCLP 重建 OpenCore 以利用这些新功能。</p><p>用户还可以在安装后菜单中查看是否已安装适用的补丁、对系统进行根修补的日期和版本。</p><table><thead><tr><th>自动安装提示</th><th>地位</th></tr></thead><tbody><tr><td><img src="/images/OCLP-GUI-root-patch-update.2ede4894.png" alt="OCLP-GUI-root-patch-update"></td><td><img src="/images/OCLP-GUI-Root-Patch-Status.88367958.png" alt="OCLP-GUI-Root-Patch-Status"></td></tr></tbody></table><h3 id="手动运行安装后补丁"><a href="#手动运行安装后补丁" class="headerlink" title="手动运行安装后补丁"></a>手动运行安装后补丁</h3><p>如果您使用的是 OCLP v0.4.3 或更早版本，或者需要手动运行修补程序，则可以使用该应用程序执行此操作。尝试运行补丁程序并没有什么坏处，因为如果没有兼容的硬件，什么也做不了。您可以在下面查看您的硬件是否需要根卷修补。</p><table><thead><tr><th>列出补丁</th><th>修补完毕</th></tr></thead><tbody><tr><td><img src="/images/OCLP-GUI-Root-Patch.8759192a.png" alt="OCLP-GUI-Root-Patch"></td><td><img src="/images/OCLP-GUI-Root-Patch-Finished.ce27b410.png" alt="OCLP-GUI-Root-Patch-Finished"></td></tr></tbody></table><p>对于 macOS Ventura 和配备 AMD Legacy GCN GPU（即 Metal）的 Mac，根修补需要网络连接来获取 Apple 的内核调试套件以开始根修补。如果您的系统无法连接到互联网，您可以从 Apple 网站手动下载 KDK：<a href="https://developer.apple.com/download/all/?q=Kernel%20Debug%20Kit" target="_blank" rel="noopener">Apple 的开发者下载页面</a></p><p>获取与您安装的操作系统版本最接近的内核调试工具包，并将其安装到运行 Ventura 的计算机上。</p><p>需要此功能的机器是配备 AMD Metal dGPU 的机器：</p><p>2008 - 2013 Mac Pro (MacPro3,1 - 6,1)</p><p>2009 - 2016 iMac（iMac10,1 - 17,1）</p><p>2015 款 15 英寸 MacBook Pro，配备 dGPU (MacBookPro11,5)</p><p>以下条目代表不再原生支持的 GPU，即。需要使用 OpenCore Legacy Patcher 修补根卷：</p><p>macOS Big Sur 中需要修补的 GPU</p><ul><li>英伟达：<ul><li>特斯拉（8000 - 300 系列）</li></ul></li><li>超微半导体：<ul><li>TeraScale（2000 - 6000 系列）</li></ul></li><li>英特尔：<ul><li>铁湖</li><li>桑迪桥（2000 - 3000 系列）</li></ul></li></ul><p>macOS Monterey 中需要修补的 GPU</p><ul><li>英伟达：<ul><li>特斯拉（8000 - 300 系列）</li><li>开普勒（600 - 800 系列）</li></ul></li><li>超微半导体：<ul><li>TeraScale（2000 - 6000 系列）</li></ul></li><li>英特尔：<ul><li>铁湖</li><li>桑迪桥（2000 - 3000 系列）</li><li>Ivy Bridge（4000 系列）</li></ul></li></ul><p>macOS Monterey 中需要修补的无线卡</p><ul><li>博通：<ul><li>BCM94328</li><li>BCM94322</li></ul></li><li>阿瑟罗斯</li></ul><p>macOS Ventura 中需要修补的 GPU</p><ul><li>英伟达：<ul><li>开普勒（600 - 800 系列）</li></ul></li><li>超微半导体：<ul><li>GCN 1-3（7000 - R9 系列）</li><li>Polaris（RX 4xx/5xx 系列，如果 CPU 缺少 AVX2）</li></ul></li><li>英特尔：<ul><li>Ivy Bridge（4000 系列）</li><li>Haswell（4400、4600、5000 系列）</li><li>布罗德韦尔（6000 系列）</li><li>Skylake（500 系列）</li></ul></li></ul><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>参考链接：<a href="https://dortania.github.io/OpenCore-Legacy-Patcher/INSTALLER.html#creating-the-installer" target="_blank" rel="noopener">https://dortania.github.io/OpenCore-Legacy-Patcher/INSTALLER.html#creating-the-installer</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;macbook2015pro已经不在macOS Sonoma支持范围内，本文讲解macbook2015pro如何升级到macOS Sonoma&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;创建安装程序&quot;&gt;&lt;a href=&quot;#创建安装程序&quot; 
      
    
    </summary>
    
      <category term="MacOS" scheme="https://blog.ifiveplus.com/categories/MacOS/"/>
    
    
      <category term="macOS" scheme="https://blog.ifiveplus.com/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Apple Magic Mouse卡顿的问题</title>
    <link href="https://blog.ifiveplus.com/AppleMagicMouse%E5%8D%A1%E9%A1%BF%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>https://blog.ifiveplus.com/AppleMagicMouse卡顿的问题.html</id>
    <published>2023-10-09T02:59:00.000Z</published>
    <updated>2023-10-30T09:55:54.537Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在公司使用<code>Apple Magic Mouse</code>时不时出现卡顿的现象，怀疑是信号干扰导致</p></blockquote><h2 id="检查速度因子"><a href="#检查速度因子" class="headerlink" title="检查速度因子"></a>检查速度因子</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default read -g com.apple.mouse.scaling</span><br></pre></td></tr></table></figure><h2 id="修改速度因子"><a href="#修改速度因子" class="headerlink" title="修改速度因子"></a>修改速度因子</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default write -g com.apple.mouse.scaling 7</span><br></pre></td></tr></table></figure><h2 id="关闭接力功能"><a href="#关闭接力功能" class="headerlink" title="关闭接力功能"></a>关闭接力功能</h2><blockquote><p><code>Hand-off</code>接力会使用<code>bluetooth</code>设备和相关频段，从而影响了蓝牙设备的通讯。<br>在<code>设置 - 通用</code>下关闭<code>接力</code></p></blockquote><p><img src="/images/49db41f09be64c56b8c05dbe17af2d58.png" alt="Hand-off"></p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>参考链接：<a href="https://blog.csdn.net/Baby_come_here/article/details/125047030" target="_blank" rel="noopener">https://blog.csdn.net/Baby_come_here/article/details/125047030</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在公司使用&lt;code&gt;Apple Magic Mouse&lt;/code&gt;时不时出现卡顿的现象，怀疑是信号干扰导致&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;检查速度因子&quot;&gt;&lt;a href=&quot;#检查速度因子&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="MacOS" scheme="https://blog.ifiveplus.com/categories/MacOS/"/>
    
    
      <category term="macOS" scheme="https://blog.ifiveplus.com/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>macOS下JD-GUI无法打开的问题</title>
    <link href="https://blog.ifiveplus.com/macOS%E4%B8%8BJD-GUI%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>https://blog.ifiveplus.com/macOS下JD-GUI无法打开的问题.html</id>
    <published>2023-10-09T02:59:00.000Z</published>
    <updated>2023-10-30T09:55:54.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在官网下载了最新版本的额JD-GUI，打开出现如下错误</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ERROR launching ‘JD-GUI’</span><br><span class="line">No suitable Java version found on your system!</span><br><span class="line">This program requires Java 1.8+</span><br><span class="line">Make sure you install the required Java version.</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>进入Contents文件下编辑<code>Info.plist</code>文件，搜索<code>1.8+</code>，然后将<code>+</code>删除掉，保存即可</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/546643868?utm_id=0" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/546643868?utm_id=0</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在官网下载了最新版本的额JD-GUI，打开出现如下错误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class
      
    
    </summary>
    
      <category term="MacOS" scheme="https://blog.ifiveplus.com/categories/MacOS/"/>
    
    
      <category term="macOS" scheme="https://blog.ifiveplus.com/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>macOS升级到Ventura后dmidecode无法使用处理方案</title>
    <link href="https://blog.ifiveplus.com/macOS%E5%8D%87%E7%BA%A7%E5%88%B0Ventura%E5%90%8Edmidecode%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88.html"/>
    <id>https://blog.ifiveplus.com/macOS升级到Ventura后dmidecode无法使用处理方案.html</id>
    <published>2023-10-09T02:59:00.000Z</published>
    <updated>2023-10-30T09:55:54.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近将主力工作机macOS升级到了Ventura，发现dmidecode无法使用，特此记录一下如何解决</p></blockquote><h2 id="下载dmidecode-osx源码"><a href="#下载dmidecode-osx源码" class="headerlink" title="下载dmidecode-osx源码"></a>下载dmidecode-osx源码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/cavaliercoder/dmidecode-osx</span><br></pre></td></tr></table></figure><h2 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/dmidecode.c b/dmidecode.c</span><br><span class="line">index bb651da.<span class="number">.194108</span>c <span class="number">100644</span></span><br><span class="line">--- a/dmidecode.c</span><br><span class="line">+++ b/dmidecode.c</span><br><span class="line">@@ <span class="number">-4811</span>,<span class="number">8</span> +<span class="number">4811</span>,<span class="number">10</span> @@ <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dmi_table</span><span class="params">(<span class="keyword">off_t</span> base, u32 len, u16 num, u32 ver, <span class="keyword">const</span> <span class="keyword">char</span> *devmem,</span></span></span><br><span class="line">          * This CFRelease throws 'Segmentation fault: 11' since macOS 10.12, if</span><br><span class="line">          * the compiled binary is <span class="keyword">not</span> <span class="keyword">signed</span> with an Apple developer profile.</span><br><span class="line">          */</span><br><span class="line">+        <span class="meta">#<span class="meta-keyword">ifdef</span> SIGNED_BINARY  <span class="comment">// So don't do that unless you signed it</span></span></span><br><span class="line">         <span class="keyword">if</span> (<span class="literal">NULL</span> != properties)</span><br><span class="line">             CFRelease(properties);</span><br><span class="line">+        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">         IOObjectRelease(service);</span><br><span class="line">     &#125;</span><br><span class="line">@@ <span class="number">-5147</span>,<span class="number">7</span> +<span class="number">5149</span>,<span class="number">7</span> @@ <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function">         <span class="keyword">goto</span> exit_free</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">-    CFDataGetBytes(dataRef, CFRangeMake(<span class="number">0</span>, <span class="number">0x20</span>), (UInt8*)buf);</span><br><span class="line">+    CFDataGetBytes(dataRef, CFRangeMake(<span class="number">0</span>, CFDataGetLength(dataRef)), (UInt8*)buf);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span> (<span class="literal">NULL</span> != dataRef)</span><br><span class="line">         CFRelease(dataRef);</span><br></pre></td></tr></table></figure><h2 id="编译-amp-安装"><a href="#编译-amp-安装" class="headerlink" title="编译&amp;安装"></a>编译&amp;安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h2 id="卸载命令"><a href="#卸载命令" class="headerlink" title="卸载命令"></a>卸载命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make uninstall</span><br></pre></td></tr></table></figure><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>源码出处：<a href="https://github.com/cavaliercoder/dmidecode-osx" target="_blank" rel="noopener">https://github.com/cavaliercoder/dmidecode-osx</a></p><p>解决方案出处：<a href="https://github.com/cavaliercoder/dmidecode-osx/issues/8" target="_blank" rel="noopener">https://github.com/cavaliercoder/dmidecode-osx/issues/8</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近将主力工作机macOS升级到了Ventura，发现dmidecode无法使用，特此记录一下如何解决&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;下载dmidecode-osx源码&quot;&gt;&lt;a href=&quot;#下载dmidecode-osx源码
      
    
    </summary>
    
      <category term="MacOS" scheme="https://blog.ifiveplus.com/categories/MacOS/"/>
    
    
      <category term="dmidecode" scheme="https://blog.ifiveplus.com/tags/dmidecode/"/>
    
  </entry>
  
  <entry>
    <title>macOS升级到Ventura后gem无法使用处理方案</title>
    <link href="https://blog.ifiveplus.com/macOS%E5%8D%87%E7%BA%A7%E5%88%B0Ventura%E5%90%8Egem%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88.html"/>
    <id>https://blog.ifiveplus.com/macOS升级到Ventura后gem无法使用处理方案.html</id>
    <published>2023-10-09T02:59:00.000Z</published>
    <updated>2023-10-30T09:55:54.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近将主力工作机macOS升级到了Ventura，发现<code>sass</code>无法安装成功，特此记录一下如何解决</p></blockquote><h2 id="错误信息参考"><a href="#错误信息参考" class="headerlink" title="错误信息参考"></a>错误信息参考</h2><blockquote><p>You don’t have write permissions for the /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/gems/2.6.0 directory.</p></blockquote><h2 id="安装Ruby"><a href="#安装Ruby" class="headerlink" title="安装Ruby"></a>安装Ruby</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ruby</span><br></pre></td></tr></table></figure><h2 id="查看ruby版本"><a href="#查看ruby版本" class="headerlink" title="查看ruby版本"></a>查看ruby版本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -v</span><br></pre></td></tr></table></figure><h2 id="安装完成后发现依旧是2-6版本，需要设置环境变量"><a href="#安装完成后发现依旧是2-6版本，需要设置环境变量" class="headerlink" title="安装完成后发现依旧是2.6版本，需要设置环境变量"></a>安装完成后发现依旧是2.6版本，需要设置环境变量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><h2 id="ARM机型粘贴以下代码"><a href="#ARM机型粘贴以下代码" class="headerlink" title="ARM机型粘贴以下代码"></a>ARM机型粘贴以下代码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ -d "/opt/homebrew/opt/ruby/bin" ]; then</span><br><span class="line">  export PATH=/opt/homebrew/opt/ruby/bin:$PATH</span><br><span class="line">  export PATH=`gem environment gemdir`/bin:$PATH</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="x86机型粘贴以下代码"><a href="#x86机型粘贴以下代码" class="headerlink" title="x86机型粘贴以下代码"></a>x86机型粘贴以下代码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ -d "/usr/local/opt/ruby/bin" ]; then</span><br><span class="line">  export PATH=/usr/local/opt/ruby/bin:$PATH</span><br><span class="line">  export PATH=`gem environment gemdir`/bin:$PATH</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="再次查看版本是否为新安装的版本"><a href="#再次查看版本是否为新安装的版本" class="headerlink" title="再次查看版本是否为新安装的版本"></a>再次查看版本是否为新安装的版本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br><span class="line">ruby -v</span><br></pre></td></tr></table></figure><h2 id="重新安装sass"><a href="#重新安装sass" class="headerlink" title="重新安装sass"></a>重新安装sass</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install sass</span><br></pre></td></tr></table></figure><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>参考链接：</p><p><a href="https://mac.install.guide/ruby/13.html" target="_blank" rel="noopener">https://mac.install.guide/ruby/13.html</a></p><p><a href="https://blog.csdn.net/liuwenchang1234/article/details/127635234" target="_blank" rel="noopener">https://blog.csdn.net/liuwenchang1234/article/details/127635234</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近将主力工作机macOS升级到了Ventura，发现&lt;code&gt;sass&lt;/code&gt;无法安装成功，特此记录一下如何解决&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;错误信息参考&quot;&gt;&lt;a href=&quot;#错误信息参考&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="MacOS" scheme="https://blog.ifiveplus.com/categories/MacOS/"/>
    
    
      <category term="gem" scheme="https://blog.ifiveplus.com/tags/gem/"/>
    
      <category term="ruby" scheme="https://blog.ifiveplus.com/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>sysbench基准测试</title>
    <link href="https://blog.ifiveplus.com/sysbench%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95.html"/>
    <id>https://blog.ifiveplus.com/sysbench基准测试.html</id>
    <published>2018-04-20T04:50:31.000Z</published>
    <updated>2023-10-30T09:55:54.549Z</updated>
    
    <content type="html"><![CDATA[<p>文件I/O(fileio)基准测试可以测试系统在不同I/O负载下的性能。这对于比较不同的硬盘驱动器、不同的RAID卡、不同的RAID模式，都很有帮助。可以根据测试结果来调整I/O子系统。文件I/O基准测试模拟了很多InnoDB的I/O特性。测试的第一步是准备(prepare)阶段，生成测试用到的数据文件，生成的数据文件至少要比内存大。如果文件中的数据能完全放入内存中，则操作系统缓存大部分的数据，导致测试结果无法体现I/O密集型的工作负载。</p><h2 id="安装sysbench"><a href="#安装sysbench" class="headerlink" title="安装sysbench"></a>安装sysbench</h2><h3 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/akopytov/sysbench/archive/1.0.zip -O <span class="string">"sysbench-1.0.zip"</span></span><br><span class="line">unzip sysbench-1.0.zip</span><br><span class="line"><span class="built_in">cd</span> sysbench-1.0</span><br></pre></td></tr></table></figure><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install automake libtool –y</span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./autogen.sh</span><br><span class="line">./configure</span><br><span class="line"><span class="comment">#这里换成机器中mysql路径下的include</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/mysql/include</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>有可能有的同学找不到include目录，不要慌，看看下面:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql-devel</span><br></pre></td></tr></table></figure><p><code>/usr/include/mysql</code>就是include目录了。</p><h2 id="内建测试-fileio测试"><a href="#内建测试-fileio测试" class="headerlink" title="内建测试: fileio测试"></a>内建测试: fileio测试</h2><h3 id="准备测试集"><a href="#准备测试集" class="headerlink" title="准备测试集"></a>准备测试集</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysbench --<span class="built_in">test</span>=fileio --file-total-size=150G prepare</span><br></pre></td></tr></table></figure><p><code>--test=fileio</code>表示测试类型为内建的fileio测试</p><p><code>--test-total-size=150G</code>表示准备测试数据集为150G大小</p><p><code>prepare</code>命令准备测试数据集</p><h3 id="查看帮助文档"><a href="#查看帮助文档" class="headerlink" title="查看帮助文档"></a>查看帮助文档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysbench --<span class="built_in">test</span>=fileio <span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>fileio options: //可用的选项</p><p>–file-num=N number of files to create [128]   //文件数量</p><p>–file-block-size=N block size to use in all IO operations [16384]  //文件块大小设定</p><p>–file-total-size=SIZE total size of files to create [2G]  //文件总大小</p><p>–file-test-mode=STRING test mode {seqwr, seqrewr, seqrd, rndrd, rndwr, rndrw}  //测试模式</p><p>–file-io-mode=STRING file operations mode {sync,async,mmap} [sync]  //io模式，“同步”、“异步”</p><p>–file-extra-flags=STRING additional flags to use on opening files {sync,dsync,direct} []</p><p>–file-fsync-freq=N do fsync() after this number of requests (0 - don’t use fsync()) [100]  //fsync()方法调用频率</p><p>–file-fsync-all=[on|off] do fsync() after each write operation [off]  //每一次写操作都进行fsync()同步，默认为off</p><p>–file-fsync-end=[on|off] do fsync() at the end of test [on]  //在测试结束之前调用fsync()同步方法</p><p>–file-fsync-mode=STRING which method to use for synchronization {fsync, fdatasync} [fsync]</p><p>–file-merged-requests=N merge at most this number of IO requests if possible (0 - don’t merge) [0]</p><p>–file-rw-ratio=N reads/writes ratio for combined<br>test [1.5]  //读写比率设定</p><p>有一个重要的测试选项：–file-test-mode=STRING。其可用的选项为：</p><p>seqwr：顺序写</p><p>seqrewr：顺序重写</p><p>seqrd：顺序读</p><p>rndrd：随机读取</p><p>rndwr：随机写入</p><p>rndrw：混合随机读/写</p><h3 id="混合随机读写测试"><a href="#混合随机读写测试" class="headerlink" title="混合随机读写测试"></a>混合随机读写测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysbench --<span class="built_in">test</span>=fileio --file-test-mode=rndrw --file-total-size=150G --file-rw-ratio=2 run</span><br></pre></td></tr></table></figure><p>选项解释：</p><p>–test-fileio：测试类型为IO测试</p><p>–file-total-size=5G：测试文件总大小为5G</p><p>–file-test-mode=rndrw：文件IO测试模式为随机混合读写方式</p><p>–file-rw-ratio=2：读写次数比率为2</p><h3 id="分析打印结果"><a href="#分析打印结果" class="headerlink" title="分析打印结果"></a>分析打印结果</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">sysbench 1.0:  multi-threaded system evaluation benchmark</span><br><span class="line"></span><br><span class="line">Running the <span class="built_in">test</span> with following options:</span><br><span class="line">Number of threads: 1    //测试线程数</span><br><span class="line">Initializing random number generator from current time</span><br><span class="line"></span><br><span class="line">//测试属性设定，可以通过选项控制</span><br><span class="line">Extra file open flags: 0</span><br><span class="line">128 files, 40MiB each</span><br><span class="line">5GiB total file size</span><br><span class="line">Block size 16KiB</span><br><span class="line">Number of IO requests: 10000</span><br><span class="line">Read/Write ratio <span class="keyword">for</span> combined random IO <span class="built_in">test</span>: 2.00</span><br><span class="line">Periodic FSYNC enabled, calling fsync() each 100 requests.</span><br><span class="line">Calling fsync() at the end of <span class="built_in">test</span>, Enabled.</span><br><span class="line">Using synchronous I/O mode</span><br><span class="line">Doing random r/w <span class="built_in">test</span></span><br><span class="line">Initializing worker threads...</span><br><span class="line"></span><br><span class="line">Threads started!</span><br><span class="line"></span><br><span class="line">//测试过程中文件操作情况</span><br><span class="line">File operations:</span><br><span class="line">    reads/s:                      95.45  //每秒钟读请求数</span><br><span class="line">    writes/s:                     47.72  //每秒钟写请求数</span><br><span class="line">    fsyncs/s:                     183.25  //没表中同步次数</span><br><span class="line"></span><br><span class="line">//吞吐率</span><br><span class="line">Throughput:</span><br><span class="line">    <span class="built_in">read</span>, MiB/s:                  1.49  //读，1.49MB每秒</span><br><span class="line">    written, MiB/s:               0.75  //写，0.75MB每秒</span><br><span class="line"></span><br><span class="line">//统计数据</span><br><span class="line">General statistics:</span><br><span class="line">    total time:                          69.8488s    //测试总时长</span><br><span class="line">    total number of events:              10000   　　//事件数量</span><br><span class="line">    total time taken by event execution: 39.6674s  　//事件执行事件</span><br><span class="line">    response time: //事件响应事件统计</span><br><span class="line">         min:                                  0.02ms   //最短</span><br><span class="line">         avg:                                  3.97ms   //平均</span><br><span class="line">         max:                                 27.70ms   //最长</span><br><span class="line">         approx.  95 percentile:              11.77ms   //95%以上事件响应时长</span><br><span class="line"></span><br><span class="line">Threads fairness:  //线程公平性统计信息</span><br><span class="line">    events (avg/stddev):           10000.0000/0.00</span><br><span class="line">    execution time (avg/stddev):   39.6674/0.00</span><br></pre></td></tr></table></figure><p>与文件IO性能评价密切相关的指标有：每秒钟请求数、吞吐量、95%以上事件响应时间。</p><h3 id="清除测试数据集"><a href="#清除测试数据集" class="headerlink" title="清除测试数据集"></a>清除测试数据集</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysbench --<span class="built_in">test</span>=fileio --file-total-size=150G cleanup</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文件I/O(fileio)基准测试可以测试系统在不同I/O负载下的性能。这对于比较不同的硬盘驱动器、不同的RAID卡、不同的RAID模式，都很有帮助。可以根据测试结果来调整I/O子系统。文件I/O基准测试模拟了很多InnoDB的I/O特性。测试的第一步是准备(prepare
      
    
    </summary>
    
      <category term="Mysql" scheme="https://blog.ifiveplus.com/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://blog.ifiveplus.com/tags/Mysql/"/>
    
      <category term="sysbench" scheme="https://blog.ifiveplus.com/tags/sysbench/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务以及事务隔离级别</title>
    <link href="https://blog.ifiveplus.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E4%BB%A5%E5%8F%8A%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html"/>
    <id>https://blog.ifiveplus.com/数据库事务以及事务隔离级别.html</id>
    <published>2018-03-15T01:34:48.000Z</published>
    <updated>2023-10-30T09:55:54.550Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章讲述数据库事务的四大特性（ACID），并详细说明事务的隔离级别。</p><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p><p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p><h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p><p>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p><p>关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</p><h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p><p>例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p><p>以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：</p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</p><p>当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> money=money+<span class="number">100</span> <span class="keyword">where</span> <span class="keyword">name</span>=’B’;  (此时A通知B)</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> money=money - <span class="number">100</span> <span class="keyword">where</span> <span class="keyword">name</span>=’A’;</span><br></pre></td></tr></table></figure><p>当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p><p>例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。</p><p>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p><p>在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……</p><h3 id="虚读（幻读）"><a href="#虚读（幻读）" class="headerlink" title="虚读（幻读）"></a>虚读（幻读）</h3><p>幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p><p>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p><p>现在来看看MySQL数据库为我们提供的四种隔离级别：</p><p>① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</p><p>② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</p><p>③ Read committed (读已提交)：可避免脏读的发生。</p><p>④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</p><p>以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。</p><p>在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。</p><p>在MySQL数据库中查看当前事务的隔离级别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @@tx_isolation;</span><br></pre></td></tr></table></figure><p>在MySQL数据库中设置事务的隔离级别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>  [glogal | <span class="keyword">session</span>]  <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> 隔离级别名称;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> tx_isolation=’隔离级别名称;’</span><br></pre></td></tr></table></figure><p>记住：设置数据库的隔离级别一定要是在开启事务之前！</p><p>如果是使用JDBC对数据库的事务设置隔离级别的话，也应该是在调用Connection对象的setAutoCommit(false)方法之前。调用Connection对象的setTransactionIsolation(level)即可设置当前链接的隔离级别，至于参数level，可以使用Connection对象的字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement st = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    conn = JdbcUtils.getConnection();</span><br><span class="line">    conn.setTransactionIsolation(Connection.TRANSACTION_SERIAIZABLE);</span><br><span class="line">    conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后记：隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>原文出处：<a href="https://www.cnblogs.com/fjdingsd/p/5273008.html" target="_blank" rel="noopener">https://www.cnblogs.com/fjdingsd/p/5273008.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇文章讲述数据库事务的四大特性（ACID），并详细说明事务的隔离级别。&lt;/p&gt;
&lt;h3 id=&quot;原子性（Atomicity）&quot;&gt;&lt;a href=&quot;#原子性（Atomicity）&quot; class=&quot;headerlink&quot; title=&quot;原子性（Atomicity）&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Mysql" scheme="https://blog.ifiveplus.com/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://blog.ifiveplus.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java图像截取</title>
    <link href="https://blog.ifiveplus.com/Java%E5%9B%BE%E5%83%8F%E6%88%AA%E5%8F%96.html"/>
    <id>https://blog.ifiveplus.com/Java图像截取.html</id>
    <published>2018-01-31T08:02:13.000Z</published>
    <updated>2023-10-30T09:55:54.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>在仔细观察QQ空间的说说、微博以及微信的图文形式，它们的缩略图都是是对原图像经过一定的切割显示的图像，那么在我开发的<code>碎片云</code>中似乎也可以加上一个类似的功能。因此需要一个图像切割的方法完成这样类似的功能，具体的切割模式可以根据自己的实际需求来进行切割，下面就是核心方法<code>ImageUtil</code>的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cloud.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Rectangle;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageReadParam;</span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageReader;</span><br><span class="line"><span class="keyword">import</span> javax.imageio.stream.ImageInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ImageUtil</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getImageWidth</span><span class="params">(<span class="keyword">int</span> port,String url)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(url.indexOf(<span class="string">"attached"</span>)&gt;-<span class="number">1</span>)&#123;</span><br><span class="line">url = <span class="string">"http://127.0.0.1:"</span>+port+url;</span><br><span class="line">&#125;</span><br><span class="line">InputStream is = <span class="keyword">new</span> URL(url).openStream();</span><br><span class="line">BufferedImage img = ImageIO.read(is);</span><br><span class="line"><span class="keyword">return</span> img.getWidth();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"><span class="comment">//e.printStackTrace();</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cutImage</span><span class="params">(String path,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> width,<span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(width &lt; <span class="number">1</span> || height &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">FileInputStream is = <span class="keyword">null</span>;</span><br><span class="line">ImageInputStream iis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 读取图片文件</span></span><br><span class="line">is = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">             * 返回包含所有当前已注册 ImageReader 的 Iterator，这些 ImageReader 声称能够解码指定格式。 </span></span><br><span class="line"><span class="comment">             * 参数：formatName - 包含非正式格式名称 . （例如 "jpeg" 或 "tiff"）等 。 </span></span><br><span class="line"><span class="comment">             */</span> </span><br><span class="line"> String fileEx = path.substring(path.lastIndexOf(<span class="string">"."</span>)+<span class="number">1</span>);</span><br><span class="line">            Iterator&lt;ImageReader&gt; it = ImageIO.getImageReadersByFormatName(fileEx);  </span><br><span class="line">            ImageReader reader = it.next();  </span><br><span class="line">            <span class="comment">// 获取图片流  </span></span><br><span class="line">            iis = ImageIO.createImageInputStream(is);  </span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * &lt;p&gt;iis:读取源.true:只向前搜索 &lt;/p&gt;.将它标记为 ‘只向前搜索’。 </span></span><br><span class="line"><span class="comment">             * 此设置意味着包含在输入源中的图像将只按顺序读取，可能允许 reader 避免缓存包含与以前已经读取的图像关联的数据的那些输入部分。 </span></span><br><span class="line"><span class="comment">             */</span>  </span><br><span class="line">            reader.setInput(iis, <span class="keyword">true</span>);  </span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * &lt;p&gt;描述如何对流进行解码的类&lt;p&gt;.用于指定如何在输入时从 Java Image I/O </span></span><br><span class="line"><span class="comment">             * 框架的上下文中的流转换一幅图像或一组图像。用于特定图像格式的插件 将从其 ImageReader 实现的 </span></span><br><span class="line"><span class="comment">             * getDefaultReadParam 方法中返回 ImageReadParam 的实例。 </span></span><br><span class="line"><span class="comment">             */</span>  </span><br><span class="line">            ImageReadParam param = reader.getDefaultReadParam();  </span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * 图片裁剪区域。Rectangle 指定了坐标空间中的一个区域，通过 Rectangle 对象 </span></span><br><span class="line"><span class="comment">             * 的左上顶点的坐标（x，y）、宽度和高度可以定义这个区域。 </span></span><br><span class="line"><span class="comment">             */</span>  </span><br><span class="line">            Rectangle rect = <span class="keyword">new</span> Rectangle(x, y, width, height);  </span><br><span class="line">            <span class="comment">// 提供一个 BufferedImage，将其用作解码像素数据的目标。  </span></span><br><span class="line">            param.setSourceRegion(rect);  </span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * 使用所提供的 ImageReadParam 读取通过索引 imageIndex 指定的对象，并将 它作为一个完整的 </span></span><br><span class="line"><span class="comment">             * BufferedImage 返回。 </span></span><br><span class="line"><span class="comment">             */</span>  </span><br><span class="line">            BufferedImage bi = reader.read(<span class="number">0</span>, param);  </span><br><span class="line">            <span class="comment">// 保存新图片  </span></span><br><span class="line">            ImageIO.write(bi, fileEx, <span class="keyword">new</span> File(path)); </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>)</span><br><span class="line">is.close();</span><br><span class="line">            <span class="keyword">if</span> (iis != <span class="keyword">null</span>) </span><br><span class="line">                iis.close(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;p&gt;在仔细观察QQ空间的说说、微博以及微信的图文形式，它们的缩略图都是是
      
    
    </summary>
    
      <category term="Java" scheme="https://blog.ifiveplus.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.ifiveplus.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringFramework BeanUtil</title>
    <link href="https://blog.ifiveplus.com/SpringFramework-BeanUtil.html"/>
    <id>https://blog.ifiveplus.com/SpringFramework-BeanUtil.html</id>
    <published>2018-01-31T07:36:05.000Z</published>
    <updated>2023-10-30T09:55:54.545Z</updated>
    
    <content type="html"><![CDATA[<p>在使用SpringMVC开发JavaWeb网站的时候，当执行Update方法的时候，需要对修改实体类的字段进行<code>set</code>操作，字段过多的时候一个个的<code>set</code>实在是一件麻烦事，于是想到了SpringFramework自带的BeanUtils方法，但是这个方法会将结果为<code>Null</code>的字段也进行拷贝，与实际Update功能不符，因此需要进行改写。</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>改写SpringFramework BeanUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cloud.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeanUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeanWrapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeanWrapperImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">BeanUtil</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写工具类BeanUtils，如果为NULL则不复制属性值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source newClass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target oldClass</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyProperties</span><span class="params">(Object source,Object target)</span></span>&#123;</span><br><span class="line">BeanUtils.copyProperties(source, target,getNullPropertyNames(source));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] getNullPropertyNames(Object source)&#123;</span><br><span class="line"><span class="keyword">final</span> BeanWrapper src = <span class="keyword">new</span> BeanWrapperImpl(source);</span><br><span class="line">java.beans.PropertyDescriptor[] pds = src.getPropertyDescriptors();</span><br><span class="line">Set&lt;String&gt; emptyNames = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span>(java.beans.PropertyDescriptor pd:pds)&#123;</span><br><span class="line">Object srcValue = src.getPropertyValue(pd.getName());</span><br><span class="line"><span class="keyword">if</span>(srcValue == <span class="keyword">null</span>) emptyNames.add(pd.getName());</span><br><span class="line">&#125;</span><br><span class="line">String[] result = <span class="keyword">new</span> String[emptyNames.size()];</span><br><span class="line"><span class="keyword">return</span> emptyNames.toArray(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>在实际使用过程中可以进行拓展，比如对<code>int</code>类型进行操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用SpringMVC开发JavaWeb网站的时候，当执行Update方法的时候，需要对修改实体类的字段进行&lt;code&gt;set&lt;/code&gt;操作，字段过多的时候一个个的&lt;code&gt;set&lt;/code&gt;实在是一件麻烦事，于是想到了SpringFramework自带的Bean
      
    
    </summary>
    
      <category term="Java" scheme="https://blog.ifiveplus.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.ifiveplus.com/tags/Java/"/>
    
      <category term="Spring" scheme="https://blog.ifiveplus.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>OpenJDK9在OSX平台下编译和调试</title>
    <link href="https://blog.ifiveplus.com/OpenJDK9%E5%9C%A8OSX%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%BC%96%E8%AF%91%E5%92%8C%E8%B0%83%E8%AF%95.html"/>
    <id>https://blog.ifiveplus.com/OpenJDK9在OSX平台下编译和调试.html</id>
    <published>2018-01-29T05:20:52.000Z</published>
    <updated>2023-10-30T09:55:54.543Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>深入理解Java虚拟机</code>一书中编译OpenJDK出现各种奇怪的错误，在这里集中做一下说明，以便日后查看。</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="安装hg"><a href="#安装hg" class="headerlink" title="安装hg"></a>安装hg</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install hg</span><br></pre></td></tr></table></figure><h3 id="下载OpenJDK源码"><a href="#下载OpenJDK源码" class="headerlink" title="下载OpenJDK源码"></a>下载OpenJDK源码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hg <span class="built_in">clone</span> http://hg.openjdk.java.net/jdk9/dev</span><br></pre></td></tr></table></figure><h3 id="安装freetype"><a href="#安装freetype" class="headerlink" title="安装freetype"></a>安装freetype</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install freetype</span><br></pre></td></tr></table></figure><h3 id="安装libffi（可选）"><a href="#安装libffi（可选）" class="headerlink" title="安装libffi（可选）"></a>安装libffi（可选）</h3><p>如果需要使用zero解释器，需要安装libffi</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install libffi</span><br></pre></td></tr></table></figure><h3 id="configure"><a href="#configure" class="headerlink" title="configure"></a>configure</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bash configure --with-debug-level=slowdebug \</span><br><span class="line">--with-freetype=/usr/<span class="built_in">local</span>/opt/freetype \</span><br><span class="line">--<span class="built_in">disable</span>-warnings-as-errors \</span><br><span class="line">--with-jvm-features=zero \</span><br><span class="line">--with-jvm-variants=zero \</span><br><span class="line">--with-libffi=/usr/<span class="built_in">local</span>/opt/libffi \</span><br><span class="line">--with-libffi-include=/usr/<span class="built_in">local</span>/Cellar/libffi/3.0.13/lib/libffi-3.0.13/include</span><br></pre></td></tr></table></figure><h4 id="–with-debug-level"><a href="#–with-debug-level" class="headerlink" title="–with-debug-level"></a>–with-debug-level</h4><p>设置调试级别，设成 slow debug 可以提供更多的调试信息</p><h4 id="–with-free-type"><a href="#–with-free-type" class="headerlink" title="–with-free-type"></a>–with-free-type</h4><p>设置 free type 路径</p><h4 id="–disable-warnings-as-errors"><a href="#–disable-warnings-as-errors" class="headerlink" title="–disable-warnings-as-errors"></a>–disable-warnings-as-errors</h4><p>忽略警告</p><h4 id="–with-jvm-features"><a href="#–with-jvm-features" class="headerlink" title="–with-jvm-features"></a>–with-jvm-features</h4><p>设置使用 c++ 实现的 zero 解释器，比基于模版的解释器更容易调试（如果汇编功力不够的话）</p><h4 id="–with-jvm-variants"><a href="#–with-jvm-variants" class="headerlink" title="–with-jvm-variants"></a>–with-jvm-variants</h4><p>配合 –with-jvm-features 使用</p><h4 id="–with-libffi"><a href="#–with-libffi" class="headerlink" title="–with-libffi"></a>–with-libffi</h4><p>配合 –with-jvm-features 使用</p><h4 id="–with-libffi-include"><a href="#–with-libffi-include" class="headerlink" title="–with-libffi-include"></a>–with-libffi-include</h4><p>设置 libffi include 文件夹路径</p><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p>在实际编译过程中出现了错误信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: ordered comparison between pointer and zero (<span class="string">'char *'</span> and <span class="string">'int'</span>)</span><br></pre></td></tr></table></figure><p>将代码<code>&gt; 0</code>或者<code>&gt;=0</code>部分改为<code>!= NULL</code>继续编译即可通过。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>编译成功后，测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/build/***/jdk/bin/java -version</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;code&gt;深入理解Java虚拟机&lt;/code&gt;一书中编译OpenJDK出现各种奇怪的错误，在这里集中做一下说明，以便日后查看。&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Java" scheme="https://blog.ifiveplus.com/categories/Java/"/>
    
    
      <category term="JDK" scheme="https://blog.ifiveplus.com/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>frp-NAS内网穿透实现</title>
    <link href="https://blog.ifiveplus.com/frp-NAS%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E7%8E%B0.html"/>
    <id>https://blog.ifiveplus.com/frp-NAS内网穿透实现.html</id>
    <published>2018-01-15T12:58:46.000Z</published>
    <updated>2023-10-30T09:55:54.546Z</updated>
    
    <content type="html"><![CDATA[<p>群晖在使用的过程中，因为没有公网IP的关系，因而需要用到内网穿透技术。使用nat123或者花生壳虽然能达到效果，奈何速度太慢，收到端口闲置颇多，因而使用frp实现内网穿透。</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>一台阿里云服务器或者VPS （服务端）</li><li>NAS（客户端）</li><li>FRP服务端以及客户端：<a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">FRP官网</a></li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>服务器端配置文件<code>frps.ini</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="string">7000</span></span><br><span class="line"><span class="attr">vhost_http_port</span> = <span class="string">8080</span></span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="string">7500</span></span><br><span class="line"><span class="attr">dashboard_user</span> = <span class="string">用户名</span></span><br><span class="line"><span class="attr">dashboard_pwd</span> = <span class="string">密码</span></span><br><span class="line"><span class="attr">max_pool_count</span> = <span class="string">5</span></span><br><span class="line"><span class="attr">authentication_timeout</span> = <span class="string">900</span></span><br><span class="line"></span><br><span class="line"><span class="attr">subdomain_host</span> = <span class="string">your_domain.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[ssh]</span></span><br><span class="line"><span class="attr">listen_port</span> = <span class="string">6000</span></span><br><span class="line"><span class="attr">auth_token</span> = <span class="string">和客服端 token 对应</span></span><br></pre></td></tr></table></figure><p>启动服务端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure><p>客户端配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="string">ip</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="string">7000</span></span><br><span class="line"><span class="attr">auth_token</span> = <span class="string">和服务器端对应</span></span><br><span class="line"><span class="attr">pool_count</span> = <span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[ssh]</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">tcp</span></span><br><span class="line"><span class="attr">local_ip</span> = <span class="string">NAS局域网ip / 127.0.0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="string">22</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="string">6000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[nas]</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">http</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="string">5000</span></span><br><span class="line"><span class="attr">subdomain</span> = <span class="string">nas</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[web]</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">http</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="string">80</span></span><br><span class="line"><span class="attr">subdomain</span> = <span class="string">web</span></span><br></pre></td></tr></table></figure><p>运行客户端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c ./frpc.ini</span><br></pre></td></tr></table></figure><h3 id="域名配置"><a href="#域名配置" class="headerlink" title="域名配置"></a>域名配置</h3><p>最后，将域名与服务器端的IP进行绑定操作即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;群晖在使用的过程中，因为没有公网IP的关系，因而需要用到内网穿透技术。使用nat123或者花生壳虽然能达到效果，奈何速度太慢，收到端口闲置颇多，因而使用frp实现内网穿透。&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; cl
      
    
    </summary>
    
      <category term="nas" scheme="https://blog.ifiveplus.com/categories/nas/"/>
    
    
      <category term="nas" scheme="https://blog.ifiveplus.com/tags/nas/"/>
    
      <category term="frp" scheme="https://blog.ifiveplus.com/tags/frp/"/>
    
  </entry>
  
  <entry>
    <title>MAC OSX环境下cordova+Ionic的安装配置</title>
    <link href="https://blog.ifiveplus.com/MAC-OSX%E7%8E%AF%E5%A2%83%E4%B8%8Bcordova-Ionic%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html"/>
    <id>https://blog.ifiveplus.com/MAC-OSX环境下cordova-Ionic的安装配置.html</id>
    <published>2018-01-05T07:49:18.000Z</published>
    <updated>2023-10-30T09:55:54.542Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>去年开始接触混合式开发APP，主要是精力有限，没办法再静下心来学swift语言的IOS开发了，开始的第一步就是环境搭建了，因为使用过Vue.js进行前端开发，所以已经有了npm和node的基础环境了。</p></blockquote><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="检查环境"><a href="#检查环境" class="headerlink" title="检查环境"></a>检查环境</h3><p>首先第一步就是检查基础安装环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>可以看到相应的版本号就表示成功。</p><h3 id="cordova安装"><a href="#cordova安装" class="headerlink" title="cordova安装"></a>cordova安装</h3><p>由于镜像在国外，网络不行，因此使用代理安装<code>cordova</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry http://registry.cnpmjs.org</span><br><span class="line">sudo npm install -g cordova</span><br></pre></td></tr></table></figure><p>输入下面命令测试是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cordova -v</span><br></pre></td></tr></table></figure><p>和上面一样，出现版本号就表示成功了。</p><h3 id="Ionic安装"><a href="#Ionic安装" class="headerlink" title="Ionic安装"></a>Ionic安装</h3><p>Ionic的安装就容易多了，直接命令行输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g ionic</span><br></pre></td></tr></table></figure><p>输入如下命令测试是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ionic -v</span><br></pre></td></tr></table></figure><h3 id="相关命令行"><a href="#相关命令行" class="headerlink" title="相关命令行"></a>相关命令行</h3><ul><li><code>ionic platform add android</code> 添加android平台</li><li><code>ionic platform add ios</code> 添加ios平台</li><li><code>ionic lib update</code> 版本库更新</li><li><code>ionic build android</code> 编译android项目</li><li><code>ionic emulate android</code>模拟器运行</li></ul><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>Ionic中的基础命令有时间再更新下，很久没写Ionic Webapp了，连环境也不记得怎么搭建了，在这里记录备份一下，用作使用参考。</p><p>More Info: <a href="https://ionicframework.com/docs/cli/" target="_blank" rel="noopener">https://ionicframework.com/docs/cli/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;去年开始接触混合式开发APP，主要是精力有限，没办法再静下心来学swift语言的IOS开发了，开始的第一步就是环境搭建了，因为使用过Vue.js进行前端开发，所以已经有了npm和node的基础环境了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 i
      
    
    </summary>
    
      <category term="Ionic" scheme="https://blog.ifiveplus.com/categories/Ionic/"/>
    
    
      <category term="ionic" scheme="https://blog.ifiveplus.com/tags/ionic/"/>
    
      <category term="cordova" scheme="https://blog.ifiveplus.com/tags/cordova/"/>
    
  </entry>
  
  <entry>
    <title>iOSOpenDev安装</title>
    <link href="https://blog.ifiveplus.com/iOSOpenDev%E5%AE%89%E8%A3%85.html"/>
    <id>https://blog.ifiveplus.com/iOSOpenDev安装.html</id>
    <published>2018-01-04T03:58:27.000Z</published>
    <updated>2023-10-30T09:55:54.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="安装-macports"><a href="#安装-macports" class="headerlink" title="安装 macports"></a>安装 <a href="https://link.jianshu.com/?t=https://www.macports.org/install.php" target="_blank" rel="noopener">macports</a></h3><p>安装完MacPorts后打开终端，输入 sudo port -v selfupdate 更新MacPorts到最新版本，时间可能比较长。</p><h3 id="安装DPKG文件"><a href="#安装DPKG文件" class="headerlink" title="安装DPKG文件"></a>安装DPKG文件</h3><p>更新完MacPorts后安装DPKG文件，在终端输入sudo port -f install dpkg</p><h3 id="安装iosopendev"><a href="#安装iosopendev" class="headerlink" title="安装iosopendev"></a>安装iosopendev</h3><p>下载安装 <a href="https://link.jianshu.com/?t=http://iosopendev.com/download/" target="_blank" rel="noopener">iosopendev</a> 如果安装失败，可以通过 Command + L 查看安装中出现的问题。如果提示以下问题请先下载 <a href="https://link.jianshu.com/?t=https://github.com/LengYi/iosOpenDev" target="_blank" rel="noopener">附件</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PackageKit: Install Failed: Error Domain=PKInstallErrorDomain Code=112 "运行软件包“iOSOpenDev-1.6-2.pkg”的脚本时出错。" UserInfo=&#123;NSFilePath=./postinstall, NSURL=file://localhost/Users/ice/Downloads/iOSOpenDev-1.6-2.pkg#iodsetup.pkg, PKInstallPackageIdentifier=com.iosopendev.iosopendev162.iod-setup.pkg, NSLocalizedDescription=运行软件包“iOSOpenDev-1.6-2.pkg”的脚本时出错。&#125; &#123;</span><br><span class="line">        NSFilePath = "./postinstall";</span><br><span class="line">        NSLocalizedDescription = "\U8fd0\U884c\U8f6f\U4ef6\U5305\U201ciOSOpenDev-1.6-2.pkg\U201d\U7684\U811a\U672c\U65f6\U51fa\U9519\U3002";</span><br><span class="line">        NSURL = "file://localhost/Users/ice/Downloads/iOSOpenDev-1.6-2.pkg#iodsetup.pkg";</span><br><span class="line">        PKInstallPackageIdentifier = "com.iosopendev.iosopendev162.iod-setup.pkg";</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="修复安装失败问题"><a href="#修复安装失败问题" class="headerlink" title="修复安装失败问题"></a>修复安装失败问题</h3><p>打开上面 <a href="https://link.jianshu.com/?t=https://github.com/LengYi/iosOpenDev" target="_blank" rel="noopener">附件</a> 里面的Specifications文件夹，里面应该有8个文件,如果你有安装多个xcode注意放到对应的xcode里面。</p><ol><li>iPhoneOS开头的四个文件放到<code>/应用程序/Xcode/Content/Developer/Platforms/IphoneOS.platform/Developer/Library/Xcode/Specifications</code>文件夹下（如果没有，请自己创建一个）</li><li>iPhone Simulator 开头的另外四个文件放入<code>/应用程序/Xcode/Content/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications</code>文件夹下(如果没有，请同样创建一个)</li><li>在<code>/应用程序/Xcode/Content/Developer/Platforms/iPhoneSimulator.platform/Developer/</code>文件夹下创建usr文件夹，usr文件夹下再创建一个名为bin的文件夹</li></ol><p>如果还是不行，重新安装iOSOpenDev,如果还是有问题请 <a href="https://link.jianshu.com/?t=http://www.cnblogs.com/xiongwj0910/p/3713290.html" target="_blank" rel="noopener">参考</a></p><h2 id="More-Info"><a href="#More-Info" class="headerlink" title="More Info"></a>More Info</h2><p>原文出处：<a href="https://www.jianshu.com/p/29580725707a" target="_blank" rel="noopener">https://www.jianshu.com/p/29580725707a</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;安装-macports&quot;&gt;&lt;a href=&quot;#安装-mac
      
    
    </summary>
    
      <category term="iOSCrack" scheme="https://blog.ifiveplus.com/categories/iOSCrack/"/>
    
    
      <category term="iOSOpenDev" scheme="https://blog.ifiveplus.com/tags/iOSOpenDev/"/>
    
  </entry>
  
</feed>
